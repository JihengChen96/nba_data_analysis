---
title: "NBA Data Analysis Project"
author: "Kate Li, Runzhe Li, Yifan Zhang, Linda Zhou"
date: "November 15, 2019"
output:
  html_document:
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
permalink: /description
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T,warning=F, message=F)
```

## Motivation and Overview
The National Basketball Association (NBA) is a professional basketball league in North America that draws the attention of many basketball fans all over the world. During the regular season, each of the 30 teams (15 in the Eastern Conference and 15 in the Western Conference) plays 82 games. At the conclusion of the regular season, the top eight teams in each conference advance to the playoffs for a chance to compete for the championship title. Towards the end of the regular season, the race for the final few playoff spots are very intense, and usually it isn't until the final game of the regular season is over when we know which teams have made the cut. As NBA fans ourselves, we are eager to find out which teams will make the playoffs this year (2019-20 NBA season), but rather than wait until next April, as data analysts, we thought it would be interesting if we could make such predictions now. We hope our analysis will lead to meaningful insights that will be of interest to NBA fans all over the world. 

## Project Objectives
The goal of this project is to build a machine learning model that can predict the winning percentages of the NBA teams in the Western Conference, and thus the playoff teams (the eight teams with the highest winning percentages). In addition to overall winning percentages, we will also provide predicted winning percentages for home games and for away games for each team.

We will undergo a comprehensive background study of the NBA to manually decide on what features to use. Then feature learning techniques will be applied. We also plan to evaluate different models. A successful model will predict the 2019-2020 NBA playoffs in the Western Conference. Ideally, the model could also be trained to predict the playoff teams in the Eastern Conference and finally round-by-round playoff predictions.


## Related Work and Literature Review


#Fivethirtyeight
Three main approaches are used to forecast NBA results: modeling the scores of the two opposing teams, the difference of scores and the outcome (win-lose) of the game. The third approach is our primary interest since it directly determines the playoffs. 

Fivethirtyeight runs NBA predictions based on a play-based statistics RAPTOR (Robust Algorithm (using) Player Tracking (and) On/Off Ratings).
The Main idea of the prediction method is to judge each team according to the current level of talent of its players and how much that talent is expected to play going forward. The talent of a player is estimated by a similarity algorithm. The algorithm finds the most similar historical comparables to estimate offensive and a defensive rating for each player based on the RAPTOR metric, which uses player tracking metrics and plus/minus data. The ratings are updated throughout the season. Each player also has an estimated playing-time for each game based on his own history and the record of his similar comparables. For a given lineup, they combine players' rating and playing-time into a team score on both sides. The team score also accounts for home-court advantage, fatigue, travel and altitude. The score is then converted into expected total points and winning probability.

The method has three major Limitations:
* Many NBA superstars are uniquely outstanding and are hard to find historical comparables. 
* Requires too much information such as the roster of every game, which is difficult to obtain and is subject to change. 
* Some of the metric are Arbrary For example, teams that played the previous day are given a penalty of 46 rating points. (Based on our analysis as presented below, fatigue does not have as much impact)

Cattelan(2013) applies a dynamic Bradley–Terry (BT) model to predict the NBA 2009-2010 regular season. The model predicts a winning probability based on the ability of the home team and visiting team. A team’s ability at home is evolutionary and depends only on past matches played at home while the ability playing away depends on past game played away. The BT model provides a good framework for analyzing paired comparison data. However, there are two limitations:
* The team ability statistic uses only information about the final result of the previous match
* The model does not include player level statistics

Cattelan inspires us to use the BT model framework for matching game prediction. We take a further look into the BT model and find several papers that compared the common methods used to model pairwise rank data. Thurstonian and Bradley–Terry models are the most commonly applied models in the analysis of paired comparison data. Handley (2001) argued that the BT formulation is more mathematically developed. Owing to its parsimony, it provides tractable maximum-likelihood estimators for scales, simultaneous confidence intervals and hypothesis tests for model fit, uniformity, and differences among populations of judges. Cattelan(2012) also compared two models and addressed some limitations to both of the models. For one thing, Bradley–Terry model requires that every comparison is performed once. When objects are specified using factors with a certain number of levels, the required sample size grows exponentially, while the number of parameters grows linearly as the number of factors increases. Thurstonian models appear particularly suitable to account for dependence between observations. However, this restriction does not apply to our study. 


#Previous application of BT model on NBA prediction
Cattelan(2013) applies a dynamic BT model to predict the NBA 2009-2010 regular season. The model predicts a winning probability based on the ability of the home team and visiting team. A team’s ability at home is evolutionary and depends only on past matches played at home while the ability playing away depends on past game played away. The BT model provides a good framework for analyzing paired comparison data. However, there are two limitations:
* uses only information about the final result of the previous match
* does not include player level statistics
We will take use of the BT model but make it better adapted to predicting NBA games. 

# Justifying BT model is good for our study
Several papers compared the common methods used to model pairwise rank data. Thurstonian and Bradley–Terry models are the most commonly applied models in the analysis of paired comparison data. Handley (2001) argued that the BT formulation is more mathematically developed. Owing to its parsimony, it provides tractable maximum-likelihood estimators for scales, simultaneous confidence intervals and hypothesis tests for model fit, uniformity, and differences among populations of judges. Cattelan(2012) also compared two models and addressed some limitations to both of the models. For one thing, Bradley–Terry model requires that every comparison is performed once. When objects are specified using factors with a certain number of levels, the required sample size grows exponentially, while the number of parameters grows linearly as the number of factors increases. Thurstonian models appear particularly suitable to account for dependence between observations. However, this restriction does not apply to our study. 






M Cattelan (2012), Models for Paired Comparison Data: A Review with Emphasis on Dependent Data, Statistical Science 2012, Vol. 27, No. 3, 412–433 DOI: 10.1214/12-STS396

J. Handley (2001), Comparative Analysis of Bradley-Terry and Thurstone-Mosteller Paired Comparison Models for Image Quality Assessment, IS&T's 2001 PICS Conference Proceedings 
Cattelan, M., Varin, C., & Firth, D. (2013). Dynamic Bradley–Terry modelling of sports tournaments. Journal of the Royal Statistical Society: Series C (Applied Statistics), 62(1), 135-150.




### Playoff Prediction 
https://projects.fivethirtyeight.com/2020-nba-predictions/
Fivethirtyeight runs NBA predictions based on a play-based stastics RAPTOR (Robust Algorithm (using) Player Tracking (and) On/Off Ratings).

* Main idea of the prediction method: each team is judged according to the current level of talent of its players and how much that talent is expected to play going forward.

* The talent of a player is estimated by a similarity algorithm. The algorithm finds the most similar historical comparables to estimate offensive and a defensive rating for each player based on the RAPTOR metric, which uses player tracking metrics and plus/minus data. The ratings are updated throughout the season.

* Each player has an estimated playing-time for each game based on his own history and the record of his similar comparables. It also takes into account of injuries and rest days. 

* For a given lineup, they combine players' rating and playing-time into a team score on both sides. That score also accounts for home-court advantage, fatigue, travel and altitude. The score are then converted into expected total points and winning probability.

Limitations:
* Many NBA superstars are uniquely outstanding and are hard find historical comparales. 
* Requires too much information such as the roster of every game, which is difficult to obtain and is subject to change. 
* Arbrary metric. For example, teams that played the previous day are given a penalty of 46 rating points. (Based on our analysis as presented below, fatigue does not have as much impact)

https://www.teamrankings.com/nba-win-picks/



### Pair-comparison data
Bradeley-Terry model

## Data 

### Data Source
All data were collected from the Basketball Reference website (https://www.basketball-reference.com/). The database contains player statistics including points per game, assists per game, rebounds per game, etc. of all players who have played in the NBA league since 1949-50 (the inaugural season of the NBA). The database also provides team statistics, including team 3-point percentages, winning percentages, etc. 

### Data Scraping 
We used the `rvest` package to scrape the following data from the Basketball Reference website:

* `team_stats`: Team statistics of the first 20 games from season 2016-17 to 2019-20. We would use these data to define team performance during a specific season in the feature engineering step.

* `game_stats`: Game results (W-L record and scores) for each of the remaining 62 games from season 2016-17 to 2018-19. We would use these data in the model building step. 

```{r,warning=F,message=F}
team_stats = readr::read_csv("./data/team_stats_all.csv")
game_stats = readr::read_csv("./data/game_stats_all.csv")
head(team_stats)
head(game_stats)

```

We do not include the code for web scraping in this rmarkdown file. Instead, please refer to the `data_scraping.R` file in the source folder for more details. Here we just show the first few rows of the data. 

### Data Wrangling
Data wrangling is performed throughout the whole data analysis process covering data tidying, exploratory data analysis, feature engineering, and model building. Here we demonstrate some necessary data wrangling procedures which were prepared for further analysis. 

We list all 30 teams in the league (both full franchasise name and abbreviation), and add an indicator to differentiate the 15 teams in the Western Conference and the 15 in the Eastern Conference.

We obtain the win shares stats (estimate of the number of wins contributed by a player) of the players ranked in the top 100 of the league in terms of win shares (WS) in a particular season. We then also identify the win shares of the player with the highest win shares on each team. For example, in the 2017-18 season, the Dallas Mavericks (DAL) team had two players ranked in the top 100 in terms of WS: Dwight Powell (WS 6.6) and Dirk Nowitzki (WS 4.8). The highest win shares of the Dallas Mavericks team is thus 6.6.

We create a function that organizes team data in the first 20 games for all teams in a particular season. This process includes extracting from a larger database relevant variables which include number of wins, number of losses, winning percentages, total points scored by team, and total points scored by opponents. We also append conference ranking of each team at the end of the first 20 games to the data by ranking the winning percentages.

We also create a function that organizes data of all regular season games in a particular season. This process includes extracting from a larger database relevant variables which include date of game, name of home team and visiting team, and points scored by home team and visiting team. We also append an indicator variable indicating whether the game was won by the home team by comparing points scored by home team and visiting team.

```{r,warning=F,message=F}
library(rvest)
library(tidyverse)

west_ind = data.frame(
  Tm = c("CHI","LAL","POR","WAS","CHO","MIL","BRK","DET","HOU","NOP","IND","MEM","DEN","LAC","ATL","NYK","MIA","ORL","DAL","PHO",
         "SAC","UTA","MIN","SAS","CLE","TOR","BOS","PHI","GSW","OKC"),
  western = c(0,1,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1),
  TeamName = c("Chicago Bulls","Los Angeles Lakers","Portland Trail Blazers", "Washington Wizards","Charlotte Hornets",
               "Milwaukee Bucks","Brooklyn Nets" ,"Detroit Pistons","Houston Rockets" ,"New Orleans Pelicans",
               "Indiana Pacers","Memphis Grizzlies","Denver Nuggets","Los Angeles Clippers","Atlanta Hawks",
               "New York Knicks" ,"Miami Heat","Orlando Magic","Dallas Mavericks","Phoenix Suns" ,
               "Sacramento Kings","Utah Jazz", "Minnesota Timberwolves","San Antonio Spurs","Cleveland Cavaliers",
               "Toronto Raptors" ,"Boston Celtics","Philadelphia 76ers" ,"Golden State Warriors","Oklahoma City Thunder")
)

get_ws_data = function(year){
  ws_url = paste0("https://www.basketball-reference.com/play-index/psl_finder.cgi?request=1&match=single&type=totals&per_minute_base=36&per_poss_base=100&season_start=1&season_end=-1&lg_id=NBA&age_min=0&age_max=99&is_playoffs=N&height_min=0&height_max=99&year_min=",
                  year,"&year_max=",year,"&birth_country_is=Y&as_comp=gt&as_val=0&pos_is_g=Y&pos_is_gf=Y&pos_is_f=Y&pos_is_fg=Y&pos_is_fc=Y&pos_is_c=Y&pos_is_cf=Y&order_by=ws")
  ws_stats = ws_url %>% read_html %>%
    html_table() %>%
    .[[1]] 
  ws_stats = ws_stats[,c(2,5,7)]
  colnames(ws_stats)= ws_stats[1,]  
  ws_stats = ws_stats[-c(1,which(ws_stats$Player=='Player')),]
  ws_stats$WS = as.numeric(ws_stats$WS )
  ws_stats_summary = ws_stats %>%
    group_by(Tm) %>%
    summarise(WS = max(WS))
  return(ws_stats_summary)
}
WinShare = get_ws_data(2018)
head(WinShare)


get_team_year_feature = function(year){
  
  #team_stats = get_team_stats() # get the team stats for all seasons
  team_stats_year = team_stats %>%
    filter(grepl(as.character(year-1),Season)) # filter the specific year 
  team_stats_year[,-c(2,3)] = as.numeric(as.matrix(team_stats_year[,-c(2,3)])) # turn characters into numeric
  
  
  ## select Win, Loss, Win-Loss per, Team points, Opponent points
  team_stats_year_feature = team_stats_year %>%
    select(Tm, W, L, `W/L%`, TeamPTS, OpponentPTS) %>%
    inner_join(west_ind, by = 'Tm')
  
  ## assign the team rank
  team_stats_year_rank = team_stats_year_feature %>%
    group_by(western) %>%
    mutate(ConfRank = order(order(W, TeamPTS, decreasing = T)))
  
  ## add the winshare feature from previous season
  Winshare  = get_ws_data(year-1)
  team_stats_year_rank = team_stats_year_rank %>% left_join(WinShare, by = 'Tm')
  team_stats_year_rank$WS[is.na(team_stats_year_rank$WS)] = 0
  
  return(team_stats_year_rank)
  
}

team_stats_18to19 = get_team_year_feature(2019)
head(team_stats_18to19)

get_game_year_feature = function(year){
  game_stats_year = game_stats %>% 
    filter(grepl(as.character(year-1),Season))
  ## game stats 
  ## the results of every game in the season 
  game_stats_feature = game_stats_year[,c(1,5,6,3,4)] 
  game_stats_feature[,c(3,5)] = as.numeric(as.matrix(game_stats_feature[,c(3,5)]))
  colnames(game_stats_feature) = c("Date","Home","HomePTS","Away","AwayPTS")
  game_stats_feature = game_stats_feature %>%
    mutate(HomeWin = ifelse(HomePTS > AwayPTS,1,0))
  return(game_stats_feature)
}
game_stats_18to19 = get_game_year_feature(2019)
head(game_stats_18to19)
```



## Exploratory Data Analysis
### Team-level 
```{r,warning=F,message=F}
WL_record_cal = function(game_schedule,WL_record){
  for(i in 1:nrow(game_schedule)){
    if (game_schedule$HomeWin[i]==1){
      WL_record$W[which(WL_record$TeamName==game_schedule$Home[i])] = 
        WL_record$W[which(WL_record$TeamName==game_schedule$Home[i])] + 1
      WL_record$L[which(WL_record$TeamName==game_schedule$Away[i])] = 
        WL_record$L[which(WL_record$TeamName==game_schedule$Away[i])] + 1
    }
    
    if (game_schedule$HomeWin[i]==0){
      WL_record$L[which(WL_record$TeamName==game_schedule$Home[i])] = 
        WL_record$L[which(WL_record$TeamName==game_schedule$Home[i])] + 1
      WL_record$W[which(WL_record$TeamName==game_schedule$Away[i])] = 
        WL_record$W[which(WL_record$TeamName==game_schedule$Away[i])] + 1
    }
  }
  return(WL_record)
}

team_def_off_plot = function(year){
  team_stats_year = get_team_year_feature(year)
  conference_names <- c(`1` = "Western Conference", `0` = "Eastern Conference")
  p = team_stats_year %>% 
    ggplot(aes(x = TeamPTS/20, y = OpponentPTS/20))+
    geom_point(aes(size = -ConfRank, col = factor(western)))+
    geom_text(aes(label=Tm),vjust = 0, nudge_y = 0.5)+
    geom_abline(slope = 1,intercept = 0,linetype="dashed", color = "red",size = 2)+
    facet_grid(~western, labeller = as_labeller(conference_names))+
    labs(title = paste0('First 20 games of Season ',year-1,'-',substr(year,3,4)))+
    theme(plot.title = element_text(hjust = 0.5))+
    coord_fixed()+
    theme(legend.position = "bottom") +
    guides(colour=FALSE) +
    scale_size("Conference standing after 20 games",breaks=c(-15,-10,-5),labels=c(15,10,5))+
    xlab("Team Points (average per game)")+
    ylab("Opponent Points (average per game)")
  print(p)
}
team_def_off_plot(2019)
```

```{r,warning=F,message=F}
team_rank_plot = function(year, Nfirst = 300){
  team_stats_year = get_team_year_feature(year)
  game_stats_year = get_game_year_feature(year)
  colnames(team_stats_year)[c(2,3)] = c("W.pre","L.pre")
  
  WL_record = cbind(west_ind,W = 0, L=0)
  WL_record  = WL_record_cal(game_stats_year,WL_record)
  colnames(WL_record)[c(4,5)] = c("W.all","L.all")
  WL_record = WL_record %>%
    group_by(western) %>%
    mutate(Season_Rank = order(order(W.all, decreasing = T))) %>%
    inner_join(team_stats_year[,c(1,2,3,8,9)],by=c("Tm","TeamName"))
  conference_names <- c(`1` = "Western Conference", `0` = "Eastern Conference")
  p = WL_record %>%
    ggplot(aes(x = ConfRank, y = Season_Rank))+
    geom_point(aes(col = factor(western)),size = 2)+
    geom_text(aes(label=Tm),vjust = 0, nudge_y = 0.5)+
    geom_abline(slope = 1,intercept = 0,linetype="dashed", color = "red",size = 2)+
    geom_hline(yintercept=8, linetype="dotted", color = "blue",size = 2)+
    facet_grid(~western, labeller = as_labeller(conference_names))+
    labs(title = paste0('Season ',year-1,'-',substr(year,3,4)))+
    theme(plot.title = element_text(hjust = 0.5))+
    coord_fixed()+
    theme(legend.position = "bottom")+
    guides(colour=FALSE)+
    xlab("Conference standing after 20 regular season games")+
    ylab("Conference standing after all 82 regular season games")
  print(p)
  
  p2 = WL_record %>%
    ggplot(aes(x = W.pre, y =W.all))+
    geom_point(aes(col = factor(western)),size = 2)+
    geom_smooth(method = "lm")+ 
    geom_text(aes(label=Tm),vjust = 0, nudge_y = 0.5)+
    facet_grid(~western, labeller = as_labeller(conference_names))+
    labs(title = paste0('Season ',year-1,'-',substr(year,3,4)))+
    theme(plot.title = element_text(hjust = 0.5))+
    theme(legend.position = "bottom")+
    xlab("Number of wins in first 20 regular season games")+
    ylab("Number of wins in all 82 regular season games")+
    guides(colour=FALSE)
  print(p2)
}

team_rank_plot(2019)
```

### Specific effect
#### Home-effect
#### Western-Eastern effect
```{r}
home_away_plot = function(year){
  game_stats_year = get_game_year_feature(year)
  standing_url = paste0("https://www.basketball-reference.com/leagues/NBA_",
                        year,"_standings.html")
  
  standing_year = standing_url %>% 
    read_html %>%
    html_nodes(xpath = '//comment()') %>%    # select comment nodes
    html_text() %>%    # extract comment text
    paste(collapse = '') %>%    # collapse to a single string
    read_html() %>%    # reparse to HTML
    html_table() %>%
    .[[1]]  
  
  colnames(standing_year) = paste0(colnames(standing_year),standing_year[1,])
  standing_year = standing_year[-1,]
  
  standing_table = standing_year %>%
    select(Team,Overall,PlaceHome,PlaceRoad,ConferenceE,ConferenceW) %>%
    separate(PlaceHome,into = c("HomeW","HomeL"),sep = "-") %>%
    separate(PlaceRoad,into = c("AwayW","AwayL"),sep = "-") %>%
    separate(ConferenceE,into = c("EastW","EastL"),sep = "-") %>%
    separate(ConferenceW,into = c("WestW","WestL"),sep = "-") %>%
    separate(Overall,into = c("Wtot","Ltot"),sep = "-") %>%
    inner_join(west_ind,by=c("Team" = "TeamName"))
  
  standing_table_gather = standing_table %>%
    gather(stats,win,-c("Team","Wtot","Ltot","Tm","western"))
  standing_table_gather[,c(2,3,7)] = as.numeric(as.matrix(standing_table_gather[,c(2,3,7)]))
  conference_names <- c(`1` = "Western Conference", `0` = "Eastern Conference")
  p = standing_table_gather %>% 
    filter(stats %in% c("HomeW","AwayW")) %>%
    ggplot(aes(x = reorder(Tm,Wtot), y = win,fill= stats))+
    geom_bar(stat = "identity",position = "dodge")+
    facet_grid(~western,scales="free_x", labeller = as_labeller(conference_names))+
    labs(title = paste0('Season ',year-1,'-',substr(year,3,4)))+
    theme(plot.title = element_text(hjust = 0.5))+
    theme(legend.position = "bottom")+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
    xlab("Teams")+
    ylab("Number of wins")+
    scale_fill_manual(values = c("#F8766D", "#00BFC4"), labels = c("Away wins", "Home wins"))+
    theme(legend.title = element_blank())
  print(p)
  
  team_factor_levels= standing_table_gather %>% 
    filter(western==1 & stats %in% c('EastW') | western==0 & stats %in% c('WestW')) %>%
    arrange(win) %>%
    select(Tm) %>% as.matrix() %>% as.character()
  
  p2 = standing_table_gather %>%
    mutate(Tm = factor(Tm,levels = team_factor_levels)) %>%
    filter(western==1 & stats %in% c('EastW','EastL') | western==0 & stats %in% c('WestW','WestL')) %>%
    ggplot(aes(x =Tm, y = win,fill= stats))+
    geom_bar(stat = "identity")+
    labs(title = paste0('Season ',year-1,'-',substr(year,3,4)))+
    theme(plot.title = element_text(hjust = 0.5))+
    theme(legend.position = "bottom")+
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
    xlab("Teams")+
    ylab("Number of wins")
  print(p2)
  
  
}

home_away_plot(2019)
```


### Player-level
```{r}
team_ws_plot = function(year){
  team_stats_year = get_team_year_feature(year)
  game_stats_year = get_game_year_feature(year)
  colnames(team_stats_year)[c(2,3)] = c("W.pre","L.pre")
  
  WL_record = cbind(west_ind,W = 0, L=0)
  WL_record  = WL_record_cal(game_stats_year,WL_record)
  colnames(WL_record)[c(4,5)] = c("W.all","L.all")
  WL_record = WL_record %>%
    group_by(western) %>%
    mutate(Season_Rank = order(order(W.all, decreasing = T))) %>%
    inner_join(team_stats_year[,c(1,2,3,8,9)],by=c("Tm","TeamName"))
  
  
  WinShare = get_ws_data(year)
  WL_record_ws = WL_record %>%
    inner_join(WinShare, by='Tm')
  
  p = WL_record_ws %>%
    ggplot(aes(x = WS, y = Season_Rank))+
    geom_point(aes(col = factor(western)),size = 2)+
    geom_text(aes(label=Tm),vjust = 0, nudge_y = 0.5)+
    facet_grid(~western)+
    labs(title = paste0('Season ',year-1,'-',substr(year,3,4)))+
    theme(plot.title = element_text(hjust = 0.5))+
    theme(legend.position = "bottom")
  print(p)
}

team_ws_plot(2019)
```

```{r}
get_ws_raw_data = function(year){
  ws_url = paste0("https://www.basketball-reference.com/play-index/psl_finder.cgi?request=1&match=single&type=totals&per_minute_base=36&per_poss_base=100&season_start=1&season_end=-1&lg_id=NBA&age_min=0&age_max=99&is_playoffs=N&height_min=0&height_max=99&year_min=",
                  year,"&year_max=",year,"&birth_country_is=Y&as_comp=gt&as_val=0&pos_is_g=Y&pos_is_gf=Y&pos_is_f=Y&pos_is_fg=Y&pos_is_fc=Y&pos_is_c=Y&pos_is_cf=Y&order_by=ws")
  ws_stats = ws_url %>% read_html %>%
    html_table() %>%
    .[[1]] 
  ws_stats = ws_stats[,c(2,3,5,7)]
  colnames(ws_stats)= ws_stats[1,]  
  ws_stats = ws_stats[-c(1,which(ws_stats$Player=='Player')),]
  ws_stats$WS = as.numeric(ws_stats$WS )
  return(ws_stats)
}




player_ws_plot = function(){
  year_list = c(2015:2019)
  ws_stats  = NULL
  for(i in 1: length(year_list)){
    ws_tmp = get_ws_raw_data(year_list[i])
    ws_stats = rbind(ws_stats, ws_tmp)
  }
  ws_stats = ws_stats %>% arrange(-WS)
  player_rank_list = unique(ws_stats$Player)
  
  ws_stats_rank = ws_stats %>%
    group_by(Season) %>%
    mutate(WSRank = rank(-WS,ties.method = "first"))
  
  p = ws_stats_rank %>%
    filter(Player %in% player_rank_list[1:20]) %>%
    ggplot(aes(x = Player, y = WSRank,fill = Player))+
    geom_boxplot()+
    #labs(title = player_rank_list[player_rank])+
    theme(plot.title = element_text(hjust = 0.5))+
    theme(legend.position = "none")+
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
  print(p)
}
player_ws_plot()

```

## Feature Engineering
The performance of a team could be captured by both the team-level and player-level statistics. The team-level features that could be included in our current model were:
* number of W and L, W/L percentage, conference rank
* team total/average points, oppponent total/average points
* other secondary statistics

The player-level features that could be incorporated in the team performance metrics were

* number of league top (50-100) win share players in the team
* highest win share value in the team

## Data Analysis

### Statistical Models: Bradley-Terry Logistic Regression Model
```{r}
library(caret)

get_train_test_data = function(year, firstN){
  team_stats_year = get_team_year_feature(year)
  game_stats_year = get_game_year_feature(year)
  
  train_set = game_stats_year[-c(1:firstN),]
  team_per_diff = data.frame(team_stats_year[match(train_set$Home,team_stats_year$TeamName),c(2,5,6,7,9,10)]
                             - team_stats_year[match(train_set$Away,team_stats_year$TeamName),c(2,5,6,7,9,10)])
  train_set_teamper = data.frame(train_set,
                                 team_per_diff = I(as.matrix(team_per_diff)))
  
  return(train_set_teamper)
}



build_logit_model_year = function(train_year = 2018, test_year = 2019, firstN = 300){
  
  train_set = get_train_test_data(train_year,firstN)
  test_set = get_train_test_data(test_year,firstN)
  
  ## logit model
  logit_model = glm(HomeWin~ team_per_diff,family=binomial(link='logit'),
                    data = train_set)
  print(summary(logit_model)) # model summary
  
  ## training accuracy
  
  print(confusionMatrix(factor(ifelse(logit_model$fitted.values>0.5,1,0)),
                        factor(train_set$HomeWin)))
  
  ## testing accuracy
  pred_win_prob = predict(logit_model,newdata = test_set, type = "response")
  pred_game = ifelse(pred_win_prob>0.5,1,0)
  
  test_set_pred = cbind(test_set,pred_win_prob,pred_game)
  print(confusionMatrix(factor(test_set_pred$pred_game),factor(test_set_pred$HomeWin)))
  return(test_set_pred)
}

test_set_pred = build_logit_model_year(2017,2018)
head(test_set_pred)
```


### Machine Learning Models: Decision Tree, Random Forest, Neural Network

### Simulation Framework
```{r}
## Remaining 60 games
set.seed(2019)
B = 100
game_simulation = function(pred_result, B, year, Nfirst = 300){
  game_stats_year = get_game_year_feature(year)
  pretrain_set = game_stats_year[1:Nfirst,]
  train_set = game_stats_year[-c(1:Nfirst),]
  WL_record = cbind(west_ind,W = 0, L=0)
  
  WL_record_pre  = WL_record_cal(pretrain_set,WL_record)
  WL_record_post = WL_record_cal(train_set,WL_record)
  WL_record_all  = WL_record_cal(train_set,WL_record_pre)
  WL_record_west = WL_record_all %>%
    filter(western==1) %>%
    arrange(-W)
  
  
  WL_simu_rep = NULL
  for(k in 1:B){
    simu_game = rep(0,nrow(pred_result))
    
    for(i in 1:nrow(pred_result)){
      simu_game[i] = rbinom(1,1, pred_result$pred_win_prob[i])
    }
    simu_result = pred_result %>%
      select(Home,Away,HomeWin) %>%
      mutate(HomeWin = simu_game)
    
    # WL_record = cbind(west_ind,W = 0, L= 0)
    WL_simu = WL_record_cal(simu_result,WL_record_pre)
    WL_simu_west = WL_simu %>%
      filter(western==1) %>%
      mutate(TeamRank = rank(-W,ties.method = "random")) %>%
      mutate(playoff = ifelse(TeamRank<=8,1,0))
    WL_simu_rep = rbind(WL_simu_rep, WL_simu_west)
  }
  ans = list(simu = WL_simu_rep, result = WL_record_west)
  return(ans)
}
simu_result = game_simulation(test_set_pred, B, year = 2018)
train_set_simu = simu_result$simu
train_set_summary = train_set_simu %>%
  group_by(Tm) %>%
  summarise(W_avg = mean(W),
            L_avg = 82 - W_avg,
            W_med = median(W),
            L_med = 82 - W_med,
            playoff_prob = sum(playoff)/B) %>%
  arrange(-W_avg)
print(train_set_summary)

WL_record_west = simu_result$result
print(WL_record_west)
```


### Extension: An Ensemble Learning Method for Integrative Prediction Using Mutiple Seasons Data

## Summary 
